/*
 * Nimbella CONFIDENTIAL
 * ---------------------
 *
 *   2018 - present Nimbella Corp
 *   All Rights Reserved.
 *
 * NOTICE:
 *
 * All information contained herein is, and remains the property of
 * Nimbella Corp and its suppliers, if any.  The intellectual and technical
 * concepts contained herein are proprietary to Nimbella Corp and its
 * suppliers and may be covered by U.S. and Foreign Patents, patents
 * in process, and are protected by trade secret or copyright law.
 *
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Nimbella Corp.
 */

const request = require('needle'),
      crypto = require('crypto'),
      fs = require('fs'),
      child_process = require('child_process'),
      path = require('path')

/**
 * The function separator string to split the path into function segments.
 */
const SEPARATOR = ';'

/**
 * Splits a string using the composition seperator character,
 * and filters all parts such that any empty segment is dropped
 * (i.e., treated as the identity function).
 */
function tokenize(path) {
  return path.split(SEPARATOR).map(x => decodeURIComponent(x.trim())).filter(x => x.length > 0 && x !== '/')
}

/**
 * Asserts that the eval'ed code is a function.
 */
function assertMainIsFunction(fn, main) {
  if (typeof fn !== 'function') {
    throw "Entrypoint '" + main + "' is not a function."
  }
}

/**
 * Waits for the fetch to complete, creates a function from the
 * response, and runs the function for the given arguments.
 *
 * fetchPromise a promise which returns the source code for the function
 * main the name of the 'main' method
 * args the args (JSON object) to pass to the function 'main'
 */
function stepFromLink(fetchPromise, main, args) {
  return fetchPromise.then(response => {
    if (response.statusCode == 200) {
      let fn = eval('(function(){' + response.body + '\nreturn ' + main + '})()')
      assertMainIsFunction(fn, main)
      return fn(args)
    } else {
      console.error(response.req.path, 'status code: ', response.statusCode)
      return Promise.reject({error: 'failed to fetch file'})
    }
  })
}

/**
 * Waits for the fetch to complete, creates a function from the
 * response which is a zip file, and runs the function for the given arguments.
 *
 * fetchPromise a promise which returns the source code for the function
 * main the name of the 'main' method
 * args the args (JSON object) to pass to the function 'main'
 */
function stepFromZip(fetchPromise, main, args) {
  return fetchPromise.then(response => {
    if (response.statusCode == 200) {
      return unzipInTmpDir(response.body, main).then(moduleDir => {
        if (!fs.existsSync(path.join(moduleDir, 'package.json')) &&
            !fs.existsSync(path.join(moduleDir, 'index.js'))) {
          return Promise.reject('Zipped actions must contain either package.json or index.js at the root.')
        }

        process.chdir(moduleDir)
        let init = (fs.existsSync(path.join(moduleDir, 'package.json')) &&
                    !fs.existsSync(path.join(moduleDir, 'node_modules'))) ? exec('npm install') : Promise.resolve(true)

        return init.then(_ => {
          try {
            fn = eval('require("' + moduleDir + '").' + main)
            assertMainIsFunction(fn, main)
            return fn(args)
          } catch (e) {
            console.error(e)
            return Promise.reject(e)
          }
        })
      })
      .catch(error => {
        return Promise.reject(error)
      })
    } else {
      console.error(response.req.path, 'status code: ', response.statusCode)
      return Promise.reject({error: 'failed to fetch file'})
    }
  })
}

/**
 * Creates a new anonymous function from the given string, and runs the
 * function for the given arguments. The string must eval to a function,
 * with one exception for projections from an object or array as in '_.a'
 * or '_[0]'.
 *
 * src the inline string representing the function
 * args the args (JSON object) to pass to the function 'main'
 */
function stepFromInlineSource(src, args) {
  return new Promise(function(resolve, reject) {
    let name = nameit()
    if (src.startsWith('_.') || src.startsWith('_[')) {
      src = `_ => ${src}`
    }
    let fn = eval(`
      (function() {
        let ${name} = ${src}
        return ${name}
      })()`)
    resolve(fn(args))
  })
}

/**
 * Helper function to run shell commands.
 */
function exec(cmd) {
  return new Promise(function (resolve, reject) {
    console.log('Executing cmd:', cmd)
    child_process.exec(cmd, function (error, stdout, stderr) {
      if (error) {
        console.error(cmd, 'failed.')
        console.error(stderr)
        reject('Command failed.')
      } else {
        resolve(stdout.trim())
      }
    })
  })
}

/**
 * Unzips the archive.
 */
function unzipInTmpDir(blob) {
  const mkTempCmd = 'mktemp -d XXXXXXXX'
  return exec(mkTempCmd).then(tmpDir => {
    console.log('Saving zip file to:', tmpDir)
    return new Promise(function (resolve, reject) {
      let zipFile = path.join(tmpDir, 'action.zip')
      fs.writeFile(zipFile, blob, function (err) {
        if (err) {
          reject('There was an error reading the action archive.')
        }
        else resolve(zipFile)
      })
    })
    .then(zipFile => {
      return exec(mkTempCmd).then(tmpDir => {
       console.log('Unzipping to:', tmpDir)
        return exec('unzip -qq ' + zipFile + ' -d ' + tmpDir).then(function (res) {
          return path.resolve(tmpDir)
        }).catch(error => {
          return Promise.reject('There was an error uncompressing the action archive.')
        })
      })
    })
  })
}

/**
 * Creates a random name for anonymous functions.
 */
function nameit() {
  // prepend an underscore to make sure identifier is valid name
  return '_' + crypto.randomBytes(8).toString('hex')
}

/**
 * Conveniently alias /github[.com]/... to the actual content path on github.com.
 */
function dealias(parts) {
  return parts.map(x => {
    if (x.startsWith('/https://')) {
      x = x.replace('/https://', '/')
    }

    if (x.startsWith('/github/')) return x.replace('/github/', '/raw.githubusercontent.com/')
    else if (x.startsWith('/github.com/') && x.indexOf('/raw/') == -1) {
      x = x.replace('/github.com/', '/raw.githubusercontent.com/')
      return x.replace('/blob/', '/')
    }
    else return x
  })
}

/**
 * If a segment name contains a @ followed by a string, that is used as the name of
 * the main function.
 */
function findMain(segment) {
  let hash = segment.indexOf('@')
  if (hash != -1) {
    let b = segment.substring(0, hash)
    let m = segment.substring(hash+1)
    return { base: b, main: m.length > 0 ? m : 'main' }
  } else return { base: segment, main: 'main' }
}

/**
 * Boxes the result of a function so that it is always an object.
 */
function boxit(result) {
  if (typeof result === 'object') return result
  else return { body: result }
}

/**
 * Returns a function to encrypt or decrypt a given message
 * (provided as string or JSON object/array). When decrypting
 * the result is either a JSON object or boxed to be one.
 */
function getCipher(keyVersion, key, path, {encoder, decoder}) {

  function partitionPathAndData(msg) {
    const i = msg.indexOf('_') // if not found this msg is malformed
    if (i > 0) {
      const pathLen = parseInt(msg.slice(0, i), 16)
      const data = msg.slice(i + 1, msg.length - 1) // last char is a '_'

      // compute the partial source path used to encrypt, if a partial path was used
      if (pathLen != 0) {
        path = path.slice(0, pathLen)
      }

      return { sourcePath: path, cipherText: data }
    } else return undefined
  }

  let encrypt = function(msg) {
    if (typeof msg == 'object') {
      msg = JSON.stringify(msg)
    }

    // a random 128 bit (16 byte) initialization vector, it ends up 32 hex chars of the encrypted value
    const iv128 = crypto.randomBytes(16)

    // if the path ends in /, it is a partial match. Otherwise, full path match (path length 0)
    let pathLen = 0
    if (path.endsWith('/') != 0) {
      pathLen = path.length
    }

    // create a 256 bit function specific hash with a secret key and the function source path
    const key256 = crypto.createHmac('sha256', key).update(path).digest()
    const cipher = crypto.createCipheriv('aes-256-cbc', key256, iv128)

    let res = keyVersion + '_' +
              iv128.toString('hex') + '_' +
              pathLen.toString(16) + '_' +
              cipher.update(msg, 'utf8', 'hex') +
              cipher.final('hex') + '_'
    return res
  }

  let decrypt = function(msg) {
    if (typeof msg == 'string' && msg.length > 32) {
      try {
        // skip version
        let i = keyVersion.length + 1 // account for '_'

        // initialization vector is first 32 hex characters of encrypted value
        const iv128 = Buffer.from(msg.slice(i, i + 32), 'hex')

        // pull out path length prefix, start offset after iv and account for '_'
        const { sourcePath, cipherText } = partitionPathAndData(msg.slice(i + 32 + 1))

        const key256 = crypto.createHmac('sha256', key).update(sourcePath).digest()
        const cipher = crypto.createDecipheriv('aes-256-cbc', key256, iv128)
        let res = cipher.update(cipherText, 'hex', 'utf8') + cipher.final('utf8')
        try {
          res = JSON.parse(res)
        } catch (e) {}
        return typeof res == 'object' ? res : { value: res }
      } catch (e) {
        console.error('failed to decrypt cipher:', msg)
        console.error(e)
        return {}
      }
    } else {
      console.error('failed to decrypt cipher because it is not a proper string:', msg)
      return {}
    }
  }

  // return decoder by default unless encoder property is a truthy
  return encoder ? encrypt : decrypt
}


function step(segment, token, prevResultPromise) {
  console.log('step:', segment)

  let next = undefined
  if (segment.startsWith('/')) {
    let { base, main } = findMain(segment)

    if (token !== undefined && base.indexOf('/raw.githubusercontent.com') == 0) {
      base += `?token=${token}`
    }

    console.log(`fetching source from https:/${base}`)

    if (!base.endsWith('.zip')) {
      next = prevResult => stepFromLink(request('get', `https:/${base}`, { follow_max: 3 }), main, prevResult)
    } else {
      next = prevResult => stepFromZip(request('get', `https:/${base}`, { follow_max: 3 }), main, prevResult)
    }
  } else {
    next = prevResult => stepFromInlineSource(segment, prevResult)
  }

  return prevResultPromise
    .then(r => {
      // currently short circuits the execution if the result is an object containing
      // an 'error' property. This may be something to extend in the future to cover
      // other errors (e.g., NaN?)
      if (typeof r == 'object' && r.error != undefined) return Promise.reject(r)
      else return r
    })
    .then(next)
    .catch(err => err)
}

function clearContext() {
  process.env.__OW_API_KEY = ''
  process.env.__OW_API_HOST = ''
  process.env.__OW_NAMESPACE = ''
  process.env.__OW_ACTION_NAME = ''
  process.env.__OW_ACTIVATION_ID = ''
  process.env.__OW_DEADLINE = ''
}

function encrypt(args) {
  clearContext()

  let cipherKey = args.__cipherKey || ''
  delete args.__cipherKey

  let cipherKeyVersion = args.__cipherKeyVersion || ''
  delete args.__cipherKeyVersion

  let path = args.__ow_path || ''
  delete args.__ow_path

  delete args.__ow_method
  delete args.__ow_headers
  delete args.__ow_user
  delete args.__ow_body
  delete args.__ow_query

  try {
    const encrypt = getCipher(cipherKeyVersion, cipherKey, path, {encoder: true})
    return { body: encrypt(args) }
  } catch (e) {
    console.error(e)
    return { body: 'Failed to encrypt value.' }
  }
}

/**
 * Decodes parameters that are encrypted and merges them with the arguments for the function to call.
 */
function decodeArgs(cipherKeyVersion, cipherKey, path, cipher, args) {
  if (cipher) {
    const decrypt = getCipher(cipherKeyVersion, cipherKey, path, {decoder: true})
    const secrets = decrypt(cipher)
    args = Object.assign({}, args, secrets) // smash secrets into secrets; in case of overlap, secerts take precedence
  }

  return args
}

function main(args) {
  clearContext()

  const path = args.__ow_path
  delete args.__ow_path

  const cipherKey = args.__cipherKey || ''
  delete args.__cipherKey

  const cipherKeyVersion = args.__cipherKeyVersion || ''
  delete args.__cipherKeyVersion

  const cipher = args.__c
  delete args.__c

  const token = args.__token
  delete args.__token

  const params = decodeArgs(cipherKeyVersion, cipherKey, path, cipher, args)
  const run = (acc, cur) => step(cur, token, acc)
  const parts = dealias(tokenize(path))
  parts.forEach(x => console.log(x))

  return parts.reduce(run, Promise.resolve(params)).then(boxit)
}

if (process.env.TEST) {
  if (process.argv[2] == 'r') {
    let keyVersion = process.argv[3]
    let key = process.argv[4]
    let path = process.argv[5]
    let params = JSON.parse(process.argv[6])
    let args = Object.assign({}, {__ow_path: path, __cipherKeyVersion: keyVersion, __cipherKey: key}, params)
    console.log(args)
    main(args).then(console.log)
  } else if (process.argv[2] == 'e') {
    let keyVersion = process.argv[3]
    let key = process.argv[4]
    let path = process.argv[5]
    let params = JSON.parse(process.argv[6])
    let args = Object.assign({}, {__ow_path: path, __cipherKeyVersion: keyVersion, __cipherKey: key}, params)
    console.log(args)
    console.log(encrypt(args))
  } else if (process.argv[2] == 'd') {
    let keyVersion = process.argv[3]
    let key = process.argv[4]
    let path = process.argv[5]
    let cipher = process.argv[6]
    console.log(decodeArgs(keyVersion, key, path, cipher))
  }
}

module.exports = { getCipher: getCipher }

//main({__ow_path:"/github.com/rabbah/bitbucket/raw/master/qr/qr2.zip", text: "hello"}).then(console.log)

//main({__ow_path:"/;_=>request('get', `https://openwhisk.ng.bluemix.net/api/v1/web/rabbah_dev/default/echo.json?text=${_.text}`);_.body", "text":"hello"}).then(console.log)

//main({__ow_path:"_ => request('get', 'https://openwhisk.ng.bluemix.net/api/v1/web/rabbah_dev/default/echo.json')^_.body", "a": "A"}).then(console.log)

//main({__ow_path:"/;_=>request('get', `http://api.funtranslations.com/translate/shakespeare.json?text=${_.text}`);_.body", "text":"hello"}).then(console.log)

//main({__ow_path: "/github.com/apache/incubator-openwhisk/master/tests/dat/actions/echo.js", "a": "A"}).then(console.log)

//main({__ow_path: "/github.com/apache/incubator-openwhisk/master/tests/dat/actions/e2cho.js", "a": "A"}).then(console.log)

//main({__ow_path: "/github/apache/incubator-openwhisk/master/tests/dat/actions/echo.js|_ => ({'msg':'hello'})", "a": "A"}).then(console.log)

//main({__ow_path: "/github/apache/incubator-openwhisk/master/tests/dat/actions/echo.js|_ => ({'msg':_+1})|/github/apache/incubator-openwhisk/master/tests/dat/actions/hello.js", "a": "A"}).then(console.log)

//main({__ow_path: "/github/apache/incubator-openwhisk/master/tests/dat/actions/echo.js|_ => ({'msg':_.x+3})", "x": 3}).then(console.log)

//main({__ow_path: "/github/apache/incubator-openwhisk/master/tests/dat/actions/echo.js|_ => ({'error':true})|/github/apache/incubator-openwhisk/master/tests/dat/actions/hello.js", "a": "A"}).then(console.log).catch(console.log)

//main({__ow_path: "/github/apache/incubator-openwhisk/master/tests/dat/actions/echo.js|_ => ({'noerror':true})|/github/apache/incubator-openwhisk/master/tests/dat/actions/hello.js", "a": "A"}).then(console.log).catch(console.log)

//main({__ow_path: "/github/apache/incubator-openwhisk/master/tests/dat/actions/echo.js,_.x,_=>_+3,_=>({payload:_}),/github/apache/incubator-openwhisk/master/tests/dat/actions/hello.js", "x": 4}).then(console.log)
